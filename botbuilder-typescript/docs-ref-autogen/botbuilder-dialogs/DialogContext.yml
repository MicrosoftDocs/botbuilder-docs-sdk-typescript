### YamlMime:UniversalReference
items:
  - uid: botbuilder-dialogs.DialogContext
    name: DialogContext
    fullName: DialogContext<C>
    children:
      - botbuilder-dialogs.DialogContext.activeDialog
      - botbuilder-dialogs.DialogContext.begin
      - botbuilder-dialogs.DialogContext.context
      - botbuilder-dialogs.DialogContext.continue
      - botbuilder-dialogs.DialogContext.constructor
      - botbuilder-dialogs.DialogContext.dialogs
      - botbuilder-dialogs.DialogContext.end
      - botbuilder-dialogs.DialogContext.endAll
      - botbuilder-dialogs.DialogContext.prompt
      - botbuilder-dialogs.DialogContext.replace
      - botbuilder-dialogs.DialogContext.stack
    langs:
      - typeScript
    type: class
    summary: A context object used to manipulate a dialog stack.
    package: botbuilder-dialogs
    remarks: >-
      This is typically created through a call to `DialogSet.createContext()`
      and is then passed

      through to all of the bots dialogs and waterfall steps.


      ```JavaScript

      const conversation = conversationState.get(context);

      const dc = dialogs.createContext(context, conversation);

      ```
  - uid: botbuilder-dialogs.DialogContext.activeDialog
    name: activeDialog
    fullName: activeDialog
    children: []
    langs:
      - typeScript
    type: property
    summary: >-
      Returns the cached instance of the active dialog on the top of the stack
      or `undefined` if

      the stack is empty.
    syntax:
      content: DialogInstance | undefined activeDialog
      return:
        type:
          - botbuilder-dialogs.DialogInstance | undefined
    package: botbuilder-dialogs
    remarks: >-
      Within a dialog or waterfall step this can be used to access the active
      dialogs state object:


      ```JavaScript

      dc.activeDialog.state.profile = {};

      ```


      Within the bots routing logic this can be used to determine if there's an
      active dialog on

      the stack:


      ```JavaScript

      if (!dc.activeDialog) {
          await dc.context.sendActivity(`No dialog is active`);
          return;
      }

      ```
  - uid: botbuilder-dialogs.DialogContext.begin
    name: begin
    children: []
    type: method
    langs:
      - typeScript
    summary: Pushes a new dialog onto the dialog stack.
    syntax:
      content: 'function begin(dialogId: string, dialogArgs?: any)'
      parameters:
        - id: dialogId
          type:
            - string
          description: ID of the dialog to start.
        - id: dialogArgs
          type:
            - any
          description: >
            (Optional) additional argument(s) to pass to the dialog being
            started.
          optional: true
      return:
        type:
          - Promise<any>
    package: botbuilder-dialogs
    remarks: >-
      This example starts a 'greeting' dialog and passes it the current user
      object:


      ```JavaScript

      await dc.begin('greeting', user);

      ```
  - uid: botbuilder-dialogs.DialogContext.context
    name: context
    fullName: context
    children: []
    langs:
      - typeScript
    type: property
    summary: Context for the current turn of conversation with the user.
    syntax:
      content: 'public context: C'
      return:
        type:
          - C
    package: botbuilder-dialogs
  - uid: botbuilder-dialogs.DialogContext.continue
    name: continue
    children: []
    type: method
    langs:
      - typeScript
    summary: 'Continues execution of the active dialog, if there is one.'
    syntax:
      content: function continue()
      parameters: []
      return:
        type:
          - Promise<any>
    package: botbuilder-dialogs
    remarks: >-
      The stack will be inspected and the active dialog will be retrieved using
      `DialogSet.find()`.

      The dialog will then have its optional `continueDialog()` method executed.
      You can check

      `context.responded` after the call completes to determine if a dialog was
      run and a reply

      was sent to the user.


      > [!NOTE]

      > If the active dialog fails to implement `continueDialog()` the
      [end()](#end) method will

      > be automatically called. This is done as a safety mechanism to avoid
      users getting trapped

      > within a dialog.


      ```JavaScript

      await dc.continue();

      if (!context.responded) {
          await dc.context.sendActivity(`I'm sorry. I didn't understand.`);
      }

      ```
  - uid: botbuilder-dialogs.DialogContext.constructor
    name: DialogContext
    children: []
    type: constructor
    langs:
      - typeScript
    summary: Creates a new DialogContext instance.
    syntax:
      content: >-
        new DialogContext(dialogs: DialogSet<C>, context: C, state: object,
        onCompleted?: (result: any) => void)
      parameters:
        - id: dialogs
          type:
            - botbuilder-dialogs.DialogSet<C>
          description: Parent dialog set.
        - id: context
          type:
            - C
          description: Context for the current turn of conversation with the user.
        - id: state
          type:
            - object
          description: State object being used to persist the dialog stack.
        - id: onCompleted
          type:
            - '(result: any) => void'
          description: >-
            (Optional) handler to call when the the last dialog on the stack
            completes.
          optional: true
    package: botbuilder-dialogs
  - uid: botbuilder-dialogs.DialogContext.dialogs
    name: dialogs
    fullName: dialogs
    children: []
    langs:
      - typeScript
    type: property
    summary: Parent dialog set.
    syntax:
      content: 'public dialogs: DialogSet<C>'
      return:
        type:
          - botbuilder-dialogs.DialogSet<C>
    package: botbuilder-dialogs
  - uid: botbuilder-dialogs.DialogContext.end
    name: end
    children: []
    type: method
    langs:
      - typeScript
    summary: >-
      Ends a dialog by popping it off the stack and returns an optional result
      to the dialogs

      parent.
    syntax:
      content: 'function end(result?: any)'
      parameters:
        - id: result
          type:
            - any
          description: >
            (Optional) result to pass to the parent dialogs `Dialog.resume()`
            method.
          optional: true
      return:
        type:
          - Promise<any>
    package: botbuilder-dialogs
    remarks: >-
      The parent dialog is the dialog the started the one being ended via a call
      to either

      [begin()](#begin) or [prompt()](#prompt).


      The parent dialog will have its `resumeDialog()` method invoked with any
      returned result.

      If the parent dialog hasn't implemented resumeDialog() then it will be
      popped off the stack

      as well and any result will be passed it its parent. If there are no more
      parent dialogs on

      the stack then processing of the turn will end.


      ```JavaScript

      dialogs.add('showUptime', [
           async function (dc) {
               const elapsed = new Date().getTime() - started;
               await dc.context.sendActivity(`I've been running for ${elapsed / 1000} seconds.`);
               await dc.end(elapsed);
           }
      ]);

      const started = new Date().getTime();

      ```
  - uid: botbuilder-dialogs.DialogContext.endAll
    name: endAll
    children: []
    type: method
    langs:
      - typeScript
    summary: >-
      Deletes any existing dialog stack thus cancelling all dialogs on the
      stack.
    syntax:
      content: function endAll()
      parameters: []
      return:
        type:
          - this
    package: botbuilder-dialogs
    remarks: >-
      As a best practice you'll typically want to call endAll() from within your
      bots interruption

      logic before starting any new dialogs:


      ```JavaScript

      await dc.endAll().begin('bookFlightTask');

      ```
  - uid: botbuilder-dialogs.DialogContext.prompt
    name: prompt
    children: []
    type: method
    langs:
      - typeScript
    summary: >-
      Helper function to simplify formatting the options for calling a prompt
      dialog.
    syntax:
      content: >-
        function prompt<O>(dialogId: string, prompt: string | Partial<Activity>,
        choicesOrOptions?: O | string | Choice[], options?: O)
      parameters:
        - id: dialogId
          type:
            - string
          description: ID of the prompt to start.
        - id: prompt
          type:
            - string | Partial<Activity>
          description: Initial prompt to send the user.
        - id: choicesOrOptions
          type:
            - 'O | string | Choice[]'
          description: >-
            (Optional) array of choices to prompt the user for or additional
            prompt options.
          optional: true
        - id: options
          type:
            - O
          description: |
            (Optional) additional prompt options.
          optional: true
      return:
        type:
          - Promise<any>
    package: botbuilder-dialogs
    remarks: >-
      This is a lightweight wrapper abound [begin()](#begin). It fills in a
      `PromptOptions`

      structure and then passes it through to `dc.begin(dialogId, options)`.


      ```JavaScript

      await dc.prompt('confirmPrompt', `Are you sure you'd like to quit?`);

      ```
  - uid: botbuilder-dialogs.DialogContext.replace
    name: replace
    children: []
    type: method
    langs:
      - typeScript
    summary: Ends the active dialog and starts a new dialog in its place.
    syntax:
      content: 'function replace(dialogId: string, dialogArgs?: any)'
      parameters:
        - id: dialogId
          type:
            - string
          description: ID of the new dialog to start.
        - id: dialogArgs
          type:
            - any
          description: |
            (Optional) additional argument(s) to pass to the new dialog.
          optional: true
      return:
        type:
          - Promise<any>
    package: botbuilder-dialogs
    remarks: >-
      This method is particularly useful for creating conversational loops
      within your bot:


      ```JavaScript

      dialogs.add('forEach', [
           async function (dc, args) {
               // Validate args
               if (!args || !args.dialogId || !Array.isArray(args.items)) { throw new Error(`forEach: invalid args`) }
               if (args.index === undefined) { args.index = 0 }

               // Persist args
               dc.activeDialog.state = args;

               // Invoke dialog with next item or end
               if (args.index < args.items.length) {
                   await dc.begin(args.dialogId, args.items[args.index]);
               } else {
                   await dc.end();
               }
           },
           function (dc) {
               // Next item
               const args = dc.activeDialog.state;
               args.index++;
               return dc.replace('forEach', args);
           }
      ]);

      ```
  - uid: botbuilder-dialogs.DialogContext.stack
    name: stack
    fullName: stack
    children: []
    langs:
      - typeScript
    type: property
    summary: Current dialog stack.
    syntax:
      content: 'public stack: DialogInstance[]'
      return:
        type:
          - 'botbuilder-dialogs.DialogInstance[]'
    package: botbuilder-dialogs
references:
  - uid: botbuilder-dialogs.DialogSet<C>
    spec.typeScript:
      - name: DialogSet
        fullName: DialogSet
        uid: botbuilder-dialogs.DialogSet
      - name: <C>
        fullName: <C>
  - uid: 'botbuilder-dialogs.DialogInstance[]'
    spec.typeScript:
      - name: DialogInstance
        fullName: DialogInstance
        uid: botbuilder-dialogs.DialogInstance
      - name: '[]'
        fullName: '[]'
  - uid: botbuilder-dialogs.DialogInstance | undefined
    spec.typeScript:
      - name: DialogInstance
        fullName: DialogInstance
        uid: botbuilder-dialogs.DialogInstance
      - name: ' | undefined'
        fullName: ' | undefined'
